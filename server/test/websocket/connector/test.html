<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Client</title>
</head>
<body>
<h1>WebSocket Client</h1>
<input type="text" id="messageInput" placeholder="Enter message">
<button onclick="sendMessage()">Send</button>
<div id="output"></div>

<script>
    const socket = new WebSocket("ws://localhost:3101/ws");
    const outputDiv = document.getElementById("output");

    socket.onopen = () => {
        outputDiv.innerHTML += "<div>Connected to WebSocket server!</div>";
        // 每隔5s发送ping消息
        setInterval(ping, 5000);
    };

    socket.onmessage = (event) => {
        // event.data 是原始的 WebSocket 数据，可能是文本或二进制（Blob 或 ArrayBuffer）
        const data = event.data;

        // 创建一个FileReader对象
        var reader = new FileReader();

        // 设置FileReader的onload事件处理程序，以便在读取操作完成后处理结果
        reader.onload = function(event) {
            // 获取 ArrayBuffer
            const arrayBuffer = event.target.result;
            console.log("arrayBuffer:", arrayBuffer)

            // 读取信息
            const dataView = new DataView(arrayBuffer)
            const messageLength = dataView.getUint16(0)
            const messageId = dataView.getUint16(2)
            const flagId = dataView.getUint16(4)

            // 从第 6 字节开始 前几字节属于请求头
            const startByte = 6;
            const slicedBuffer = arrayBuffer.slice(startByte);

            // 转化为文本
            var text = arrayBufferToText(slicedBuffer)
            // 打印提取的 ArrayBuffer 数据
            console.log("messageInfo messageLength:", messageLength, " messageId:", messageId, " flagId:", flagId, " text:", text)

            if (messageId === 5) {
                console.log("SCPingAck")
            } else {
                outputDiv.innerHTML += `<div>Received: ${text}</div>`;
            }
        };

        // 使用FileReader的readAsText方法读取Blob
        reader.readAsArrayBuffer(data);
    };

    socket.onclose = () => {
        outputDiv.innerHTML += "<div>Connection closed!</div>";
    };

    socket.onerror = (error) => {
        outputDiv.innerHTML += `<div>Error: ${error}</div>`;
    };

    function sendMessage() {
        const messageContent = document.getElementById("messageInput").value;

        var fullMessage = marshal(messageContent, 1)
        console.log("fullMessage:", fullMessage)

        // 发送包含消息头和消息内容的二进制数据
        socket.send(fullMessage);

        outputDiv.innerHTML += `<div>Sent: ${messageContent}</div>`;
        document.getElementById("messageInput").value = "";  //清空输入框
    }

    // msgId 由后端定义
    function marshal(messageContent, msgId) {
        const encoder = new TextEncoder();
        const messageData = encoder.encode(messageContent);

        // 计算消息的长度（2 字节）
        const messageLength = messageData.length;

        // 选择消息类型（2 字节）
        const messageId = msgId;

        // 加密方式（2 字节）
        const flagId = 1;

        // 组装消息包：2 字节长度 + 2 字节类型 + 2 字节加密方式
        const messageHeader = new ArrayBuffer(6);
        const headerView = new DataView(messageHeader);

        // 设置消息长度（2 字节）
        headerView.setUint16(0, messageLength, false); // 大端字节序
        // 设置消息类型（2 字节）
        headerView.setUint16(2, messageId);
        // 设置加密方式（2 字节）
        headerView.setUint16(4, flagId);

        // 将消息头和消息内容合并成一个完整的消息包
        var fullMessage = new Uint8Array(6 + messageLength);
        fullMessage.set(new Uint8Array(messageHeader), 0); // 消息头
        fullMessage.set(messageData, 6); // 消息内容
        return fullMessage
    }

    // 将 ArrayBuffer 转换为文本（假设是 UTF-8 编码）
    function arrayBufferToText(arrayBuffer) {
        const decoder = new TextDecoder('utf-8');
        return decoder.decode(arrayBuffer);
    }

    function ping() {
        let emptyJsonString = "{}";
        var msg = marshal(emptyJsonString, 4)
        console.log("CSPingReq:", msg)
        socket.send(msg)
    }
</script>
</body>
</html>